play {
  application {
    loader = com.namely.chiefofstate.SidecarApplicationLoader
  }
  http {
    secret.key = "ahshrefhefjhefeboefvfvofefevelvenv"
    secret.key = ${?APPLICATION_SECRET}
  }
  server {
    provider = "play.core.server.AkkaHttpServerProvider"
    pidfile {
      path = /dev/null
    }
    http {
      # The default address is all address in case the environment variable PLAY_HTTP_ADDRESS and
      # properties file entry http.address are not found
      address = "0.0.0.0"
      address = ${?PLAY_HTTP_ADDRESS}
      address = ${?http.address}

      # The default port will be 9000 in case the environment variable PLAY_HTTP_PORT and properties
      # entry http.port are not found
      port = 9000
      port = ${?PLAY_HTTP_PORT}
      port = ${?http.port}

      # The idle timeout for an open connection after which it will be closed
      # Set to null or "infinite" to disable the timeout, but notice that this
      # is not encouraged since timeout are important mechanisms to protect your
      # servers from malicious attacks or programming mistakes.
      idleTimeout = 75 seconds
    }
  }
}

db {
  default {
    url = "jdbc:postgresql://localhost:5432/postgres"
    username = "postgres"
    password = "changeme"
  }
}

lagom {
  persistence {
    jdbc {
      create-tables {
        auto = true
      }
    }
  }

  cluster {
    # exit jvm on actor system termination
    # this will allow Kubernetes to restart the pod
    exit-jvm-when-system-terminated = on
    bootstrap {
      enabled = on
    }
  }

  broker {
    kafka {
      brokers = ${?KAFKA_BROKER}
      brokers = "localhost:9092"
      # disable kafka-native
      service-name = ""
    }
  }
}

akka {
  kafka {
    producer {
      kafka-clients {
        bootstrap.servers = "localhost:9092"
        bootstrap.servers = ${?KAFKA_BROKER}
        security.protocol = PLAINTEXT
      }
    }
  }
}

namely {
  service-name = "chiefofstate.service"
  service-name = ${?SERVICE_NAME}
  team = ""
  team = ${?TEAM_NAME}
}

lagom-common {
  snaphsot-criteria {
    # number of events to batch persist
    frequency = 2
    # number of snapshots to retain
    retention = 2
  }

  events {
    # the events tag name. It is recommended to use the service name
    # because the event tag name must be unique and cannot be changed once the application has handled
    # an aggregate event.
    # Reference: https://www.lagomframework.com/documentation/latest/scala/ReadSide.html#Refactoring-Consideration
    tagname: ${namely.service-name}
  }
}
