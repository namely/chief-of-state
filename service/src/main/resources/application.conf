include "lagom-common.conf"
play {
	modules.enabled += "com.namely.protobuf.chief_of_state.AkkaGrpcClientModule"
	application {
		loader = com.namely.chiefofstate.ChiefOfStateApplicationLoader
	}
	http {
		secret.key = "ahshrefhefjhefeboefvfvofefevelvenv"
		secret.key = ${?APPLICATION_SECRET}
	}
	server {
		provider = "play.core.server.AkkaHttpServerProvider"
		pidfile {
			path = /dev/null
		}
		http {
			# The default address is all address in case the environment variable PLAY_HTTP_ADDRESS and
			# properties file entry http.address are not found
			address = "0.0.0.0"
			address = ${?COS_ADDRESS}

			# The default port will be 9000 in case the environment variable PLAY_HTTP_PORT and properties
			# entry http.port are not found
			port = 9000
			port = ${?COS_PORT}

			# The idle timeout for an open connection after which it will be closed
			# Set to null or "infinite" to disable the timeout, but notice that this
			# is not encouraged since timeout are important mechanisms to protect your
			# servers from malicious attacks or programming mistakes.
			idleTimeout = 75 seconds
		}
	}
}

db {
	default {
		driver = "org.postgresql.Driver"
		username = "postgres"
		password = "changeme"
		username = ${?COS_POSTGRES_USER}
		password = ${?COS_POSTGRES_PASSWORD}
		host = "localhost"
		host = ${?COS_POSTGRES_HOST}
		port = "5432"
		port = ${?COS_POSTGRES_PORT}
		database = "postgres"
		database = ${?COS_POSTGRES_DB}
		schema = "public"
		schema = ${?COS_POSTGRES_SCHEMA}
		url = "jdbc:postgresql://"${db.default.host}":"${db.default.port}"/"${db.default.database}"?currentSchema="${db.default.schema}
	}
}

lagom {

	cluster {
		# exit jvm on actor system termination
		# this will allow Kubernetes to restart the pod
		exit-jvm-when-system-terminated = on
		bootstrap {
			enabled = on
		}
	}

	broker {
		kafka {
			brokers = "localhost:9092"
			brokers = ${?COS_KAFKA_BROKER}
			# disable kafka-native
			service-name = ""
		}
	}
}

akka {
	kafka {
		producer {
			kafka-clients {
				bootstrap.servers = "localhost:9092"
				bootstrap.servers = ${?COS_KAFKA_BROKER}
				security.protocol = PLAINTEXT
			}
		}
	}

	grpc {
		client {
			"chief_of_state.HandlerService" {
				# Host to use if service-discovery-mechanism is set to static or grpc-dns
				host = ${HANDLER_SERVICE_HOST}

				# port to use if service-discovery-mechism is static or service discovery does not return a port
				port = ${HANDLER_SERVICE_PORT}

				service-discovery {
					mechanism = "static"
					# Service name to use if a service-discovery.mechanism other than static or grpc-dns
					service-name = ""
					# See https://doc.akka.io/docs/akka-management/current/discovery/index.html for meanings for each mechanism
					# if blank then not passed to the lookup
					port-name = ""
					protocol = ""

					# timeout for service discovery resolving
					resolve-timeout = 1s
				}

				# pick_first or round_robin
				# TODO: test more policies, add support by using io.grpc.internal.AbstractManagedChannelImplBuilder.defaultServiceConfig
				grpc-load-balancing = ""

				deadline = infinite
				override-authority = ""
				user-agent = ""
				# Pulls default configuration from ssl-config-core's reference.conf
				ssl-config = ${ssl-config}
				use-tls = false

				# TODO: Enforce HTTP/2 TLS restrictions: https://tools.ietf.org/html/draft-ietf-httpbis-http2-17#section-9.2

				creation {
					# How many times to retry client creation before giving up
					attempts = 1000

					# How long to wait between client creation attempts
					delay = 400ms
				}

				connection-attempts = -1

				# Service discovery mechamism to use. The default is to use a static host
				# and port that will be resolved via DNS.
				# Any of the mechanisms described in https://doc.akka.io/docs/akka-management/current/discovery/index.html can be used
				# including Kubernetes, Consul, AWS API
			}
		}
	}
}

namely {
	service-name = "chiefofstate"
	service-name = ${?COS_SERVICE_NAME}
	team = ""
	team = ${?TEAM_NAME}
}

lagom-common {
	snaphsot-criteria {
		# number of events to batch persist
		frequency = 2
		# number of snapshots to retain
		retention = 2
	}

	events {
		# the events tag name. It is recommended to use the service name
		# because the event tag name must be unique and cannot be changed once the application has handled
		# an aggregate event.
		# Reference: https://www.lagomframework.com/documentation/latest/scala/ReadSide.html#Refactoring-Consideration
		tagname: "chiefofstate"
	}
}

chief-of-state {
	# define settings for the handler services
	handlers-settings {
		# define the fully qualified name of the state proto
		# example: namely.org_units.OrgUnit
		state-proto = ${HANDLER_SERVICE_STATE_PROTO}
		# list if the fully qualified name of the events handled
		# example: "namely.org_units.OrgUnitTypeCreated", "namely.org_units.OrgUnitTypeUpdated"
		events-protos = ${HANDLER_SERVICE_EVENTS_PROTOS}
	}
}
